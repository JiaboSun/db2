// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: global_lock_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_global_5flock_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_global_5flock_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 4000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 4000000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_global_5flock_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_global_5flock_5fservice_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_global_5flock_5fservice_2eproto;
namespace dbx1000 {
class GetNextTsReply;
class GetNextTsReplyDefaultTypeInternal;
extern GetNextTsReplyDefaultTypeInternal _GetNextTsReply_default_instance_;
class GetNextTsRequest;
class GetNextTsRequestDefaultTypeInternal;
extern GetNextTsRequestDefaultTypeInternal _GetNextTsRequest_default_instance_;
class GlobalLockInitDoneReply;
class GlobalLockInitDoneReplyDefaultTypeInternal;
extern GlobalLockInitDoneReplyDefaultTypeInternal _GlobalLockInitDoneReply_default_instance_;
class GlobalLockInitDoneRequest;
class GlobalLockInitDoneRequestDefaultTypeInternal;
extern GlobalLockInitDoneRequestDefaultTypeInternal _GlobalLockInitDoneRequest_default_instance_;
class InstanceInitDoneReply;
class InstanceInitDoneReplyDefaultTypeInternal;
extern InstanceInitDoneReplyDefaultTypeInternal _InstanceInitDoneReply_default_instance_;
class InstanceInitDoneRequest;
class InstanceInitDoneRequestDefaultTypeInternal;
extern InstanceInitDoneRequestDefaultTypeInternal _InstanceInitDoneRequest_default_instance_;
class InvalidReply;
class InvalidReplyDefaultTypeInternal;
extern InvalidReplyDefaultTypeInternal _InvalidReply_default_instance_;
class InvalidRequest;
class InvalidRequestDefaultTypeInternal;
extern InvalidRequestDefaultTypeInternal _InvalidRequest_default_instance_;
class LockRemoteReply;
class LockRemoteReplyDefaultTypeInternal;
extern LockRemoteReplyDefaultTypeInternal _LockRemoteReply_default_instance_;
class LockRemoteRequest;
class LockRemoteRequestDefaultTypeInternal;
extern LockRemoteRequestDefaultTypeInternal _LockRemoteRequest_default_instance_;
class TestReply;
class TestReplyDefaultTypeInternal;
extern TestReplyDefaultTypeInternal _TestReply_default_instance_;
class TestRequest;
class TestRequestDefaultTypeInternal;
extern TestRequestDefaultTypeInternal _TestRequest_default_instance_;
}  // namespace dbx1000
PROTOBUF_NAMESPACE_OPEN
template<> ::dbx1000::GetNextTsReply* Arena::CreateMaybeMessage<::dbx1000::GetNextTsReply>(Arena*);
template<> ::dbx1000::GetNextTsRequest* Arena::CreateMaybeMessage<::dbx1000::GetNextTsRequest>(Arena*);
template<> ::dbx1000::GlobalLockInitDoneReply* Arena::CreateMaybeMessage<::dbx1000::GlobalLockInitDoneReply>(Arena*);
template<> ::dbx1000::GlobalLockInitDoneRequest* Arena::CreateMaybeMessage<::dbx1000::GlobalLockInitDoneRequest>(Arena*);
template<> ::dbx1000::InstanceInitDoneReply* Arena::CreateMaybeMessage<::dbx1000::InstanceInitDoneReply>(Arena*);
template<> ::dbx1000::InstanceInitDoneRequest* Arena::CreateMaybeMessage<::dbx1000::InstanceInitDoneRequest>(Arena*);
template<> ::dbx1000::InvalidReply* Arena::CreateMaybeMessage<::dbx1000::InvalidReply>(Arena*);
template<> ::dbx1000::InvalidRequest* Arena::CreateMaybeMessage<::dbx1000::InvalidRequest>(Arena*);
template<> ::dbx1000::LockRemoteReply* Arena::CreateMaybeMessage<::dbx1000::LockRemoteReply>(Arena*);
template<> ::dbx1000::LockRemoteRequest* Arena::CreateMaybeMessage<::dbx1000::LockRemoteRequest>(Arena*);
template<> ::dbx1000::TestReply* Arena::CreateMaybeMessage<::dbx1000::TestReply>(Arena*);
template<> ::dbx1000::TestRequest* Arena::CreateMaybeMessage<::dbx1000::TestRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace dbx1000 {

enum RpcLockMode : int {
  O = 0,
  P = 1,
  S = 2,
  X = 3,
  RpcLockMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RpcLockMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RpcLockMode_IsValid(int value);
constexpr RpcLockMode RpcLockMode_MIN = O;
constexpr RpcLockMode RpcLockMode_MAX = X;
constexpr int RpcLockMode_ARRAYSIZE = RpcLockMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RpcLockMode_descriptor();
template<typename T>
inline const std::string& RpcLockMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RpcLockMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RpcLockMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RpcLockMode_descriptor(), enum_t_value);
}
inline bool RpcLockMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RpcLockMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RpcLockMode>(
    RpcLockMode_descriptor(), name, value);
}
enum RpcRC : int {
  RCOK = 0,
  Commit = 1,
  Abort = 2,
  WAIT = 3,
  ERROR = 4,
  FINISH = 5,
  TIME_OUT = 6,
  RpcRC_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RpcRC_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RpcRC_IsValid(int value);
constexpr RpcRC RpcRC_MIN = RCOK;
constexpr RpcRC RpcRC_MAX = TIME_OUT;
constexpr int RpcRC_ARRAYSIZE = RpcRC_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RpcRC_descriptor();
template<typename T>
inline const std::string& RpcRC_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RpcRC>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RpcRC_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RpcRC_descriptor(), enum_t_value);
}
inline bool RpcRC_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RpcRC* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RpcRC>(
    RpcRC_descriptor(), name, value);
}
// ===================================================================

class LockRemoteRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dbx1000.LockRemoteRequest) */ {
 public:
  inline LockRemoteRequest() : LockRemoteRequest(nullptr) {}
  virtual ~LockRemoteRequest();

  LockRemoteRequest(const LockRemoteRequest& from);
  LockRemoteRequest(LockRemoteRequest&& from) noexcept
    : LockRemoteRequest() {
    *this = ::std::move(from);
  }

  inline LockRemoteRequest& operator=(const LockRemoteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockRemoteRequest& operator=(LockRemoteRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LockRemoteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LockRemoteRequest* internal_default_instance() {
    return reinterpret_cast<const LockRemoteRequest*>(
               &_LockRemoteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LockRemoteRequest& a, LockRemoteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LockRemoteRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockRemoteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LockRemoteRequest* New() const final {
    return CreateMaybeMessage<LockRemoteRequest>(nullptr);
  }

  LockRemoteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LockRemoteRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LockRemoteRequest& from);
  void MergeFrom(const LockRemoteRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockRemoteRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dbx1000.LockRemoteRequest";
  }
  protected:
  explicit LockRemoteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_global_5flock_5fservice_2eproto);
    return ::descriptor_table_global_5flock_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageBufFieldNumber = 4,
    kPageIdFieldNumber = 2,
    kInstanceIdFieldNumber = 1,
    kReqModeFieldNumber = 3,
    kCountFieldNumber = 5,
  };
  // bytes page_buf = 4;
  void clear_page_buf();
  const std::string& page_buf() const;
  void set_page_buf(const std::string& value);
  void set_page_buf(std::string&& value);
  void set_page_buf(const char* value);
  void set_page_buf(const void* value, size_t size);
  std::string* mutable_page_buf();
  std::string* release_page_buf();
  void set_allocated_page_buf(std::string* page_buf);
  private:
  const std::string& _internal_page_buf() const;
  void _internal_set_page_buf(const std::string& value);
  std::string* _internal_mutable_page_buf();
  public:

  // uint64 page_id = 2;
  void clear_page_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 page_id() const;
  void set_page_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_page_id() const;
  void _internal_set_page_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // int32 instance_id = 1;
  void clear_instance_id();
  ::PROTOBUF_NAMESPACE_ID::int32 instance_id() const;
  void set_instance_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_instance_id() const;
  void _internal_set_instance_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .dbx1000.RpcLockMode req_mode = 3;
  void clear_req_mode();
  ::dbx1000::RpcLockMode req_mode() const;
  void set_req_mode(::dbx1000::RpcLockMode value);
  private:
  ::dbx1000::RpcLockMode _internal_req_mode() const;
  void _internal_set_req_mode(::dbx1000::RpcLockMode value);
  public:

  // uint64 count = 5;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:dbx1000.LockRemoteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_buf_;
  ::PROTOBUF_NAMESPACE_ID::uint64 page_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 instance_id_;
  int req_mode_;
  ::PROTOBUF_NAMESPACE_ID::uint64 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_global_5flock_5fservice_2eproto;
};
// -------------------------------------------------------------------

class LockRemoteReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dbx1000.LockRemoteReply) */ {
 public:
  inline LockRemoteReply() : LockRemoteReply(nullptr) {}
  virtual ~LockRemoteReply();

  LockRemoteReply(const LockRemoteReply& from);
  LockRemoteReply(LockRemoteReply&& from) noexcept
    : LockRemoteReply() {
    *this = ::std::move(from);
  }

  inline LockRemoteReply& operator=(const LockRemoteReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline LockRemoteReply& operator=(LockRemoteReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LockRemoteReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LockRemoteReply* internal_default_instance() {
    return reinterpret_cast<const LockRemoteReply*>(
               &_LockRemoteReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LockRemoteReply& a, LockRemoteReply& b) {
    a.Swap(&b);
  }
  inline void Swap(LockRemoteReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LockRemoteReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LockRemoteReply* New() const final {
    return CreateMaybeMessage<LockRemoteReply>(nullptr);
  }

  LockRemoteReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LockRemoteReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LockRemoteReply& from);
  void MergeFrom(const LockRemoteReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LockRemoteReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dbx1000.LockRemoteReply";
  }
  protected:
  explicit LockRemoteReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_global_5flock_5fservice_2eproto);
    return ::descriptor_table_global_5flock_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageBufFieldNumber = 2,
    kCountFieldNumber = 3,
    kRcFieldNumber = 1,
  };
  // bytes page_buf = 2;
  void clear_page_buf();
  const std::string& page_buf() const;
  void set_page_buf(const std::string& value);
  void set_page_buf(std::string&& value);
  void set_page_buf(const char* value);
  void set_page_buf(const void* value, size_t size);
  std::string* mutable_page_buf();
  std::string* release_page_buf();
  void set_allocated_page_buf(std::string* page_buf);
  private:
  const std::string& _internal_page_buf() const;
  void _internal_set_page_buf(const std::string& value);
  std::string* _internal_mutable_page_buf();
  public:

  // uint64 count = 3;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .dbx1000.RpcRC rc = 1;
  void clear_rc();
  ::dbx1000::RpcRC rc() const;
  void set_rc(::dbx1000::RpcRC value);
  private:
  ::dbx1000::RpcRC _internal_rc() const;
  void _internal_set_rc(::dbx1000::RpcRC value);
  public:

  // @@protoc_insertion_point(class_scope:dbx1000.LockRemoteReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_buf_;
  ::PROTOBUF_NAMESPACE_ID::uint64 count_;
  int rc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_global_5flock_5fservice_2eproto;
};
// -------------------------------------------------------------------

class InstanceInitDoneRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dbx1000.InstanceInitDoneRequest) */ {
 public:
  inline InstanceInitDoneRequest() : InstanceInitDoneRequest(nullptr) {}
  virtual ~InstanceInitDoneRequest();

  InstanceInitDoneRequest(const InstanceInitDoneRequest& from);
  InstanceInitDoneRequest(InstanceInitDoneRequest&& from) noexcept
    : InstanceInitDoneRequest() {
    *this = ::std::move(from);
  }

  inline InstanceInitDoneRequest& operator=(const InstanceInitDoneRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstanceInitDoneRequest& operator=(InstanceInitDoneRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InstanceInitDoneRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InstanceInitDoneRequest* internal_default_instance() {
    return reinterpret_cast<const InstanceInitDoneRequest*>(
               &_InstanceInitDoneRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(InstanceInitDoneRequest& a, InstanceInitDoneRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InstanceInitDoneRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstanceInitDoneRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstanceInitDoneRequest* New() const final {
    return CreateMaybeMessage<InstanceInitDoneRequest>(nullptr);
  }

  InstanceInitDoneRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstanceInitDoneRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InstanceInitDoneRequest& from);
  void MergeFrom(const InstanceInitDoneRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstanceInitDoneRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dbx1000.InstanceInitDoneRequest";
  }
  protected:
  explicit InstanceInitDoneRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_global_5flock_5fservice_2eproto);
    return ::descriptor_table_global_5flock_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstanceIdFieldNumber = 1,
  };
  // int32 instance_id = 1;
  void clear_instance_id();
  ::PROTOBUF_NAMESPACE_ID::int32 instance_id() const;
  void set_instance_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_instance_id() const;
  void _internal_set_instance_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dbx1000.InstanceInitDoneRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 instance_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_global_5flock_5fservice_2eproto;
};
// -------------------------------------------------------------------

class InstanceInitDoneReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dbx1000.InstanceInitDoneReply) */ {
 public:
  inline InstanceInitDoneReply() : InstanceInitDoneReply(nullptr) {}
  virtual ~InstanceInitDoneReply();

  InstanceInitDoneReply(const InstanceInitDoneReply& from);
  InstanceInitDoneReply(InstanceInitDoneReply&& from) noexcept
    : InstanceInitDoneReply() {
    *this = ::std::move(from);
  }

  inline InstanceInitDoneReply& operator=(const InstanceInitDoneReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline InstanceInitDoneReply& operator=(InstanceInitDoneReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InstanceInitDoneReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InstanceInitDoneReply* internal_default_instance() {
    return reinterpret_cast<const InstanceInitDoneReply*>(
               &_InstanceInitDoneReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(InstanceInitDoneReply& a, InstanceInitDoneReply& b) {
    a.Swap(&b);
  }
  inline void Swap(InstanceInitDoneReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InstanceInitDoneReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InstanceInitDoneReply* New() const final {
    return CreateMaybeMessage<InstanceInitDoneReply>(nullptr);
  }

  InstanceInitDoneReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InstanceInitDoneReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InstanceInitDoneReply& from);
  void MergeFrom(const InstanceInitDoneReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InstanceInitDoneReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dbx1000.InstanceInitDoneReply";
  }
  protected:
  explicit InstanceInitDoneReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_global_5flock_5fservice_2eproto);
    return ::descriptor_table_global_5flock_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dbx1000.InstanceInitDoneReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_global_5flock_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GlobalLockInitDoneRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dbx1000.GlobalLockInitDoneRequest) */ {
 public:
  inline GlobalLockInitDoneRequest() : GlobalLockInitDoneRequest(nullptr) {}
  virtual ~GlobalLockInitDoneRequest();

  GlobalLockInitDoneRequest(const GlobalLockInitDoneRequest& from);
  GlobalLockInitDoneRequest(GlobalLockInitDoneRequest&& from) noexcept
    : GlobalLockInitDoneRequest() {
    *this = ::std::move(from);
  }

  inline GlobalLockInitDoneRequest& operator=(const GlobalLockInitDoneRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalLockInitDoneRequest& operator=(GlobalLockInitDoneRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GlobalLockInitDoneRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GlobalLockInitDoneRequest* internal_default_instance() {
    return reinterpret_cast<const GlobalLockInitDoneRequest*>(
               &_GlobalLockInitDoneRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GlobalLockInitDoneRequest& a, GlobalLockInitDoneRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalLockInitDoneRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalLockInitDoneRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GlobalLockInitDoneRequest* New() const final {
    return CreateMaybeMessage<GlobalLockInitDoneRequest>(nullptr);
  }

  GlobalLockInitDoneRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GlobalLockInitDoneRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GlobalLockInitDoneRequest& from);
  void MergeFrom(const GlobalLockInitDoneRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalLockInitDoneRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dbx1000.GlobalLockInitDoneRequest";
  }
  protected:
  explicit GlobalLockInitDoneRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_global_5flock_5fservice_2eproto);
    return ::descriptor_table_global_5flock_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dbx1000.GlobalLockInitDoneRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_global_5flock_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GlobalLockInitDoneReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dbx1000.GlobalLockInitDoneReply) */ {
 public:
  inline GlobalLockInitDoneReply() : GlobalLockInitDoneReply(nullptr) {}
  virtual ~GlobalLockInitDoneReply();

  GlobalLockInitDoneReply(const GlobalLockInitDoneReply& from);
  GlobalLockInitDoneReply(GlobalLockInitDoneReply&& from) noexcept
    : GlobalLockInitDoneReply() {
    *this = ::std::move(from);
  }

  inline GlobalLockInitDoneReply& operator=(const GlobalLockInitDoneReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalLockInitDoneReply& operator=(GlobalLockInitDoneReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GlobalLockInitDoneReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GlobalLockInitDoneReply* internal_default_instance() {
    return reinterpret_cast<const GlobalLockInitDoneReply*>(
               &_GlobalLockInitDoneReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GlobalLockInitDoneReply& a, GlobalLockInitDoneReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalLockInitDoneReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalLockInitDoneReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GlobalLockInitDoneReply* New() const final {
    return CreateMaybeMessage<GlobalLockInitDoneReply>(nullptr);
  }

  GlobalLockInitDoneReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GlobalLockInitDoneReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GlobalLockInitDoneReply& from);
  void MergeFrom(const GlobalLockInitDoneReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalLockInitDoneReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dbx1000.GlobalLockInitDoneReply";
  }
  protected:
  explicit GlobalLockInitDoneReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_global_5flock_5fservice_2eproto);
    return ::descriptor_table_global_5flock_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitDoneFieldNumber = 1,
  };
  // bool init_done = 1;
  void clear_init_done();
  bool init_done() const;
  void set_init_done(bool value);
  private:
  bool _internal_init_done() const;
  void _internal_set_init_done(bool value);
  public:

  // @@protoc_insertion_point(class_scope:dbx1000.GlobalLockInitDoneReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool init_done_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_global_5flock_5fservice_2eproto;
};
// -------------------------------------------------------------------

class InvalidRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dbx1000.InvalidRequest) */ {
 public:
  inline InvalidRequest() : InvalidRequest(nullptr) {}
  virtual ~InvalidRequest();

  InvalidRequest(const InvalidRequest& from);
  InvalidRequest(InvalidRequest&& from) noexcept
    : InvalidRequest() {
    *this = ::std::move(from);
  }

  inline InvalidRequest& operator=(const InvalidRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvalidRequest& operator=(InvalidRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InvalidRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InvalidRequest* internal_default_instance() {
    return reinterpret_cast<const InvalidRequest*>(
               &_InvalidRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InvalidRequest& a, InvalidRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InvalidRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvalidRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InvalidRequest* New() const final {
    return CreateMaybeMessage<InvalidRequest>(nullptr);
  }

  InvalidRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InvalidRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InvalidRequest& from);
  void MergeFrom(const InvalidRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvalidRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dbx1000.InvalidRequest";
  }
  protected:
  explicit InvalidRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_global_5flock_5fservice_2eproto);
    return ::descriptor_table_global_5flock_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageBufFieldNumber = 2,
    kPageIdFieldNumber = 1,
    kCountFieldNumber = 3,
  };
  // bytes page_buf = 2;
  void clear_page_buf();
  const std::string& page_buf() const;
  void set_page_buf(const std::string& value);
  void set_page_buf(std::string&& value);
  void set_page_buf(const char* value);
  void set_page_buf(const void* value, size_t size);
  std::string* mutable_page_buf();
  std::string* release_page_buf();
  void set_allocated_page_buf(std::string* page_buf);
  private:
  const std::string& _internal_page_buf() const;
  void _internal_set_page_buf(const std::string& value);
  std::string* _internal_mutable_page_buf();
  public:

  // uint64 page_id = 1;
  void clear_page_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 page_id() const;
  void set_page_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_page_id() const;
  void _internal_set_page_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 count = 3;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:dbx1000.InvalidRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_buf_;
  ::PROTOBUF_NAMESPACE_ID::uint64 page_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_global_5flock_5fservice_2eproto;
};
// -------------------------------------------------------------------

class InvalidReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dbx1000.InvalidReply) */ {
 public:
  inline InvalidReply() : InvalidReply(nullptr) {}
  virtual ~InvalidReply();

  InvalidReply(const InvalidReply& from);
  InvalidReply(InvalidReply&& from) noexcept
    : InvalidReply() {
    *this = ::std::move(from);
  }

  inline InvalidReply& operator=(const InvalidReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvalidReply& operator=(InvalidReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InvalidReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InvalidReply* internal_default_instance() {
    return reinterpret_cast<const InvalidReply*>(
               &_InvalidReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InvalidReply& a, InvalidReply& b) {
    a.Swap(&b);
  }
  inline void Swap(InvalidReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvalidReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InvalidReply* New() const final {
    return CreateMaybeMessage<InvalidReply>(nullptr);
  }

  InvalidReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InvalidReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InvalidReply& from);
  void MergeFrom(const InvalidReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvalidReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dbx1000.InvalidReply";
  }
  protected:
  explicit InvalidReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_global_5flock_5fservice_2eproto);
    return ::descriptor_table_global_5flock_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageBufFieldNumber = 2,
    kCountFieldNumber = 3,
    kRcFieldNumber = 1,
  };
  // bytes page_buf = 2;
  void clear_page_buf();
  const std::string& page_buf() const;
  void set_page_buf(const std::string& value);
  void set_page_buf(std::string&& value);
  void set_page_buf(const char* value);
  void set_page_buf(const void* value, size_t size);
  std::string* mutable_page_buf();
  std::string* release_page_buf();
  void set_allocated_page_buf(std::string* page_buf);
  private:
  const std::string& _internal_page_buf() const;
  void _internal_set_page_buf(const std::string& value);
  std::string* _internal_mutable_page_buf();
  public:

  // uint64 count = 3;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .dbx1000.RpcRC rc = 1;
  void clear_rc();
  ::dbx1000::RpcRC rc() const;
  void set_rc(::dbx1000::RpcRC value);
  private:
  ::dbx1000::RpcRC _internal_rc() const;
  void _internal_set_rc(::dbx1000::RpcRC value);
  public:

  // @@protoc_insertion_point(class_scope:dbx1000.InvalidReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_buf_;
  ::PROTOBUF_NAMESPACE_ID::uint64 count_;
  int rc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_global_5flock_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetNextTsRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dbx1000.GetNextTsRequest) */ {
 public:
  inline GetNextTsRequest() : GetNextTsRequest(nullptr) {}
  virtual ~GetNextTsRequest();

  GetNextTsRequest(const GetNextTsRequest& from);
  GetNextTsRequest(GetNextTsRequest&& from) noexcept
    : GetNextTsRequest() {
    *this = ::std::move(from);
  }

  inline GetNextTsRequest& operator=(const GetNextTsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNextTsRequest& operator=(GetNextTsRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetNextTsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNextTsRequest* internal_default_instance() {
    return reinterpret_cast<const GetNextTsRequest*>(
               &_GetNextTsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetNextTsRequest& a, GetNextTsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNextTsRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNextTsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetNextTsRequest* New() const final {
    return CreateMaybeMessage<GetNextTsRequest>(nullptr);
  }

  GetNextTsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetNextTsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetNextTsRequest& from);
  void MergeFrom(const GetNextTsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNextTsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dbx1000.GetNextTsRequest";
  }
  protected:
  explicit GetNextTsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_global_5flock_5fservice_2eproto);
    return ::descriptor_table_global_5flock_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dbx1000.GetNextTsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_global_5flock_5fservice_2eproto;
};
// -------------------------------------------------------------------

class GetNextTsReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dbx1000.GetNextTsReply) */ {
 public:
  inline GetNextTsReply() : GetNextTsReply(nullptr) {}
  virtual ~GetNextTsReply();

  GetNextTsReply(const GetNextTsReply& from);
  GetNextTsReply(GetNextTsReply&& from) noexcept
    : GetNextTsReply() {
    *this = ::std::move(from);
  }

  inline GetNextTsReply& operator=(const GetNextTsReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNextTsReply& operator=(GetNextTsReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetNextTsReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetNextTsReply* internal_default_instance() {
    return reinterpret_cast<const GetNextTsReply*>(
               &_GetNextTsReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetNextTsReply& a, GetNextTsReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNextTsReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNextTsReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetNextTsReply* New() const final {
    return CreateMaybeMessage<GetNextTsReply>(nullptr);
  }

  GetNextTsReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetNextTsReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetNextTsReply& from);
  void MergeFrom(const GetNextTsReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNextTsReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dbx1000.GetNextTsReply";
  }
  protected:
  explicit GetNextTsReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_global_5flock_5fservice_2eproto);
    return ::descriptor_table_global_5flock_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTsFieldNumber = 1,
  };
  // uint64 ts = 1;
  void clear_ts();
  ::PROTOBUF_NAMESPACE_ID::uint64 ts() const;
  void set_ts(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_ts() const;
  void _internal_set_ts(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:dbx1000.GetNextTsReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_global_5flock_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TestRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dbx1000.TestRequest) */ {
 public:
  inline TestRequest() : TestRequest(nullptr) {}
  virtual ~TestRequest();

  TestRequest(const TestRequest& from);
  TestRequest(TestRequest&& from) noexcept
    : TestRequest() {
    *this = ::std::move(from);
  }

  inline TestRequest& operator=(const TestRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestRequest& operator=(TestRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TestRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestRequest* internal_default_instance() {
    return reinterpret_cast<const TestRequest*>(
               &_TestRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TestRequest& a, TestRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TestRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TestRequest* New() const final {
    return CreateMaybeMessage<TestRequest>(nullptr);
  }

  TestRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TestRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TestRequest& from);
  void MergeFrom(const TestRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dbx1000.TestRequest";
  }
  protected:
  explicit TestRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_global_5flock_5fservice_2eproto);
    return ::descriptor_table_global_5flock_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:dbx1000.TestRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_global_5flock_5fservice_2eproto;
};
// -------------------------------------------------------------------

class TestReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dbx1000.TestReply) */ {
 public:
  inline TestReply() : TestReply(nullptr) {}
  virtual ~TestReply();

  TestReply(const TestReply& from);
  TestReply(TestReply&& from) noexcept
    : TestReply() {
    *this = ::std::move(from);
  }

  inline TestReply& operator=(const TestReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline TestReply& operator=(TestReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TestReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TestReply* internal_default_instance() {
    return reinterpret_cast<const TestReply*>(
               &_TestReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TestReply& a, TestReply& b) {
    a.Swap(&b);
  }
  inline void Swap(TestReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TestReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TestReply* New() const final {
    return CreateMaybeMessage<TestReply>(nullptr);
  }

  TestReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TestReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TestReply& from);
  void MergeFrom(const TestReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TestReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dbx1000.TestReply";
  }
  protected:
  explicit TestReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_global_5flock_5fservice_2eproto);
    return ::descriptor_table_global_5flock_5fservice_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRcFieldNumber = 1,
  };
  // int32 rc = 1;
  void clear_rc();
  ::PROTOBUF_NAMESPACE_ID::int32 rc() const;
  void set_rc(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rc() const;
  void _internal_set_rc(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:dbx1000.TestReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 rc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_global_5flock_5fservice_2eproto;
};
// ===================================================================

class GlobalLockService_Stub;

class GlobalLockService : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline GlobalLockService() {};
 public:
  virtual ~GlobalLockService();

  typedef GlobalLockService_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void LockRemote(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dbx1000::LockRemoteRequest* request,
                       ::dbx1000::LockRemoteReply* response,
                       ::google::protobuf::Closure* done);
  virtual void InstanceInitDone(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dbx1000::InstanceInitDoneRequest* request,
                       ::dbx1000::InstanceInitDoneReply* response,
                       ::google::protobuf::Closure* done);
  virtual void GlobalLockInitDone(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dbx1000::GlobalLockInitDoneRequest* request,
                       ::dbx1000::GlobalLockInitDoneReply* response,
                       ::google::protobuf::Closure* done);
  virtual void GetNextTs(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dbx1000::GetNextTsRequest* request,
                       ::dbx1000::GetNextTsReply* response,
                       ::google::protobuf::Closure* done);
  virtual void Invalid(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dbx1000::InvalidRequest* request,
                       ::dbx1000::InvalidReply* response,
                       ::google::protobuf::Closure* done);
  virtual void Test(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dbx1000::TestRequest* request,
                       ::dbx1000::TestReply* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(GlobalLockService);
};

class GlobalLockService_Stub : public GlobalLockService {
 public:
  GlobalLockService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  GlobalLockService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~GlobalLockService_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements GlobalLockService ------------------------------------------

  void LockRemote(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dbx1000::LockRemoteRequest* request,
                       ::dbx1000::LockRemoteReply* response,
                       ::google::protobuf::Closure* done);
  void InstanceInitDone(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dbx1000::InstanceInitDoneRequest* request,
                       ::dbx1000::InstanceInitDoneReply* response,
                       ::google::protobuf::Closure* done);
  void GlobalLockInitDone(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dbx1000::GlobalLockInitDoneRequest* request,
                       ::dbx1000::GlobalLockInitDoneReply* response,
                       ::google::protobuf::Closure* done);
  void GetNextTs(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dbx1000::GetNextTsRequest* request,
                       ::dbx1000::GetNextTsReply* response,
                       ::google::protobuf::Closure* done);
  void Invalid(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dbx1000::InvalidRequest* request,
                       ::dbx1000::InvalidReply* response,
                       ::google::protobuf::Closure* done);
  void Test(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::dbx1000::TestRequest* request,
                       ::dbx1000::TestReply* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(GlobalLockService_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LockRemoteRequest

// int32 instance_id = 1;
inline void LockRemoteRequest::clear_instance_id() {
  instance_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LockRemoteRequest::_internal_instance_id() const {
  return instance_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 LockRemoteRequest::instance_id() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockRemoteRequest.instance_id)
  return _internal_instance_id();
}
inline void LockRemoteRequest::_internal_set_instance_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  instance_id_ = value;
}
inline void LockRemoteRequest::set_instance_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_instance_id(value);
  // @@protoc_insertion_point(field_set:dbx1000.LockRemoteRequest.instance_id)
}

// uint64 page_id = 2;
inline void LockRemoteRequest::clear_page_id() {
  page_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LockRemoteRequest::_internal_page_id() const {
  return page_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LockRemoteRequest::page_id() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockRemoteRequest.page_id)
  return _internal_page_id();
}
inline void LockRemoteRequest::_internal_set_page_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  page_id_ = value;
}
inline void LockRemoteRequest::set_page_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_page_id(value);
  // @@protoc_insertion_point(field_set:dbx1000.LockRemoteRequest.page_id)
}

// .dbx1000.RpcLockMode req_mode = 3;
inline void LockRemoteRequest::clear_req_mode() {
  req_mode_ = 0;
}
inline ::dbx1000::RpcLockMode LockRemoteRequest::_internal_req_mode() const {
  return static_cast< ::dbx1000::RpcLockMode >(req_mode_);
}
inline ::dbx1000::RpcLockMode LockRemoteRequest::req_mode() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockRemoteRequest.req_mode)
  return _internal_req_mode();
}
inline void LockRemoteRequest::_internal_set_req_mode(::dbx1000::RpcLockMode value) {
  
  req_mode_ = value;
}
inline void LockRemoteRequest::set_req_mode(::dbx1000::RpcLockMode value) {
  _internal_set_req_mode(value);
  // @@protoc_insertion_point(field_set:dbx1000.LockRemoteRequest.req_mode)
}

// bytes page_buf = 4;
inline void LockRemoteRequest::clear_page_buf() {
  page_buf_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& LockRemoteRequest::page_buf() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockRemoteRequest.page_buf)
  return _internal_page_buf();
}
inline void LockRemoteRequest::set_page_buf(const std::string& value) {
  _internal_set_page_buf(value);
  // @@protoc_insertion_point(field_set:dbx1000.LockRemoteRequest.page_buf)
}
inline std::string* LockRemoteRequest::mutable_page_buf() {
  // @@protoc_insertion_point(field_mutable:dbx1000.LockRemoteRequest.page_buf)
  return _internal_mutable_page_buf();
}
inline const std::string& LockRemoteRequest::_internal_page_buf() const {
  return page_buf_.Get();
}
inline void LockRemoteRequest::_internal_set_page_buf(const std::string& value) {
  
  page_buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LockRemoteRequest::set_page_buf(std::string&& value) {
  
  page_buf_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dbx1000.LockRemoteRequest.page_buf)
}
inline void LockRemoteRequest::set_page_buf(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  page_buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:dbx1000.LockRemoteRequest.page_buf)
}
inline void LockRemoteRequest::set_page_buf(const void* value,
    size_t size) {
  
  page_buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dbx1000.LockRemoteRequest.page_buf)
}
inline std::string* LockRemoteRequest::_internal_mutable_page_buf() {
  
  return page_buf_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LockRemoteRequest::release_page_buf() {
  // @@protoc_insertion_point(field_release:dbx1000.LockRemoteRequest.page_buf)
  return page_buf_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LockRemoteRequest::set_allocated_page_buf(std::string* page_buf) {
  if (page_buf != nullptr) {
    
  } else {
    
  }
  page_buf_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), page_buf,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dbx1000.LockRemoteRequest.page_buf)
}

// uint64 count = 5;
inline void LockRemoteRequest::clear_count() {
  count_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LockRemoteRequest::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LockRemoteRequest::count() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockRemoteRequest.count)
  return _internal_count();
}
inline void LockRemoteRequest::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  count_ = value;
}
inline void LockRemoteRequest::set_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:dbx1000.LockRemoteRequest.count)
}

// -------------------------------------------------------------------

// LockRemoteReply

// .dbx1000.RpcRC rc = 1;
inline void LockRemoteReply::clear_rc() {
  rc_ = 0;
}
inline ::dbx1000::RpcRC LockRemoteReply::_internal_rc() const {
  return static_cast< ::dbx1000::RpcRC >(rc_);
}
inline ::dbx1000::RpcRC LockRemoteReply::rc() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockRemoteReply.rc)
  return _internal_rc();
}
inline void LockRemoteReply::_internal_set_rc(::dbx1000::RpcRC value) {
  
  rc_ = value;
}
inline void LockRemoteReply::set_rc(::dbx1000::RpcRC value) {
  _internal_set_rc(value);
  // @@protoc_insertion_point(field_set:dbx1000.LockRemoteReply.rc)
}

// bytes page_buf = 2;
inline void LockRemoteReply::clear_page_buf() {
  page_buf_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& LockRemoteReply::page_buf() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockRemoteReply.page_buf)
  return _internal_page_buf();
}
inline void LockRemoteReply::set_page_buf(const std::string& value) {
  _internal_set_page_buf(value);
  // @@protoc_insertion_point(field_set:dbx1000.LockRemoteReply.page_buf)
}
inline std::string* LockRemoteReply::mutable_page_buf() {
  // @@protoc_insertion_point(field_mutable:dbx1000.LockRemoteReply.page_buf)
  return _internal_mutable_page_buf();
}
inline const std::string& LockRemoteReply::_internal_page_buf() const {
  return page_buf_.Get();
}
inline void LockRemoteReply::_internal_set_page_buf(const std::string& value) {
  
  page_buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void LockRemoteReply::set_page_buf(std::string&& value) {
  
  page_buf_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dbx1000.LockRemoteReply.page_buf)
}
inline void LockRemoteReply::set_page_buf(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  page_buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:dbx1000.LockRemoteReply.page_buf)
}
inline void LockRemoteReply::set_page_buf(const void* value,
    size_t size) {
  
  page_buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dbx1000.LockRemoteReply.page_buf)
}
inline std::string* LockRemoteReply::_internal_mutable_page_buf() {
  
  return page_buf_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* LockRemoteReply::release_page_buf() {
  // @@protoc_insertion_point(field_release:dbx1000.LockRemoteReply.page_buf)
  return page_buf_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void LockRemoteReply::set_allocated_page_buf(std::string* page_buf) {
  if (page_buf != nullptr) {
    
  } else {
    
  }
  page_buf_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), page_buf,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dbx1000.LockRemoteReply.page_buf)
}

// uint64 count = 3;
inline void LockRemoteReply::clear_count() {
  count_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LockRemoteReply::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 LockRemoteReply::count() const {
  // @@protoc_insertion_point(field_get:dbx1000.LockRemoteReply.count)
  return _internal_count();
}
inline void LockRemoteReply::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  count_ = value;
}
inline void LockRemoteReply::set_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:dbx1000.LockRemoteReply.count)
}

// -------------------------------------------------------------------

// InstanceInitDoneRequest

// int32 instance_id = 1;
inline void InstanceInitDoneRequest::clear_instance_id() {
  instance_id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InstanceInitDoneRequest::_internal_instance_id() const {
  return instance_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 InstanceInitDoneRequest::instance_id() const {
  // @@protoc_insertion_point(field_get:dbx1000.InstanceInitDoneRequest.instance_id)
  return _internal_instance_id();
}
inline void InstanceInitDoneRequest::_internal_set_instance_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  instance_id_ = value;
}
inline void InstanceInitDoneRequest::set_instance_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_instance_id(value);
  // @@protoc_insertion_point(field_set:dbx1000.InstanceInitDoneRequest.instance_id)
}

// -------------------------------------------------------------------

// InstanceInitDoneReply

// -------------------------------------------------------------------

// GlobalLockInitDoneRequest

// -------------------------------------------------------------------

// GlobalLockInitDoneReply

// bool init_done = 1;
inline void GlobalLockInitDoneReply::clear_init_done() {
  init_done_ = false;
}
inline bool GlobalLockInitDoneReply::_internal_init_done() const {
  return init_done_;
}
inline bool GlobalLockInitDoneReply::init_done() const {
  // @@protoc_insertion_point(field_get:dbx1000.GlobalLockInitDoneReply.init_done)
  return _internal_init_done();
}
inline void GlobalLockInitDoneReply::_internal_set_init_done(bool value) {
  
  init_done_ = value;
}
inline void GlobalLockInitDoneReply::set_init_done(bool value) {
  _internal_set_init_done(value);
  // @@protoc_insertion_point(field_set:dbx1000.GlobalLockInitDoneReply.init_done)
}

// -------------------------------------------------------------------

// InvalidRequest

// uint64 page_id = 1;
inline void InvalidRequest::clear_page_id() {
  page_id_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InvalidRequest::_internal_page_id() const {
  return page_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InvalidRequest::page_id() const {
  // @@protoc_insertion_point(field_get:dbx1000.InvalidRequest.page_id)
  return _internal_page_id();
}
inline void InvalidRequest::_internal_set_page_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  page_id_ = value;
}
inline void InvalidRequest::set_page_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_page_id(value);
  // @@protoc_insertion_point(field_set:dbx1000.InvalidRequest.page_id)
}

// bytes page_buf = 2;
inline void InvalidRequest::clear_page_buf() {
  page_buf_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& InvalidRequest::page_buf() const {
  // @@protoc_insertion_point(field_get:dbx1000.InvalidRequest.page_buf)
  return _internal_page_buf();
}
inline void InvalidRequest::set_page_buf(const std::string& value) {
  _internal_set_page_buf(value);
  // @@protoc_insertion_point(field_set:dbx1000.InvalidRequest.page_buf)
}
inline std::string* InvalidRequest::mutable_page_buf() {
  // @@protoc_insertion_point(field_mutable:dbx1000.InvalidRequest.page_buf)
  return _internal_mutable_page_buf();
}
inline const std::string& InvalidRequest::_internal_page_buf() const {
  return page_buf_.Get();
}
inline void InvalidRequest::_internal_set_page_buf(const std::string& value) {
  
  page_buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void InvalidRequest::set_page_buf(std::string&& value) {
  
  page_buf_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dbx1000.InvalidRequest.page_buf)
}
inline void InvalidRequest::set_page_buf(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  page_buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:dbx1000.InvalidRequest.page_buf)
}
inline void InvalidRequest::set_page_buf(const void* value,
    size_t size) {
  
  page_buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dbx1000.InvalidRequest.page_buf)
}
inline std::string* InvalidRequest::_internal_mutable_page_buf() {
  
  return page_buf_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* InvalidRequest::release_page_buf() {
  // @@protoc_insertion_point(field_release:dbx1000.InvalidRequest.page_buf)
  return page_buf_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InvalidRequest::set_allocated_page_buf(std::string* page_buf) {
  if (page_buf != nullptr) {
    
  } else {
    
  }
  page_buf_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), page_buf,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dbx1000.InvalidRequest.page_buf)
}

// uint64 count = 3;
inline void InvalidRequest::clear_count() {
  count_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InvalidRequest::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InvalidRequest::count() const {
  // @@protoc_insertion_point(field_get:dbx1000.InvalidRequest.count)
  return _internal_count();
}
inline void InvalidRequest::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  count_ = value;
}
inline void InvalidRequest::set_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:dbx1000.InvalidRequest.count)
}

// -------------------------------------------------------------------

// InvalidReply

// .dbx1000.RpcRC rc = 1;
inline void InvalidReply::clear_rc() {
  rc_ = 0;
}
inline ::dbx1000::RpcRC InvalidReply::_internal_rc() const {
  return static_cast< ::dbx1000::RpcRC >(rc_);
}
inline ::dbx1000::RpcRC InvalidReply::rc() const {
  // @@protoc_insertion_point(field_get:dbx1000.InvalidReply.rc)
  return _internal_rc();
}
inline void InvalidReply::_internal_set_rc(::dbx1000::RpcRC value) {
  
  rc_ = value;
}
inline void InvalidReply::set_rc(::dbx1000::RpcRC value) {
  _internal_set_rc(value);
  // @@protoc_insertion_point(field_set:dbx1000.InvalidReply.rc)
}

// bytes page_buf = 2;
inline void InvalidReply::clear_page_buf() {
  page_buf_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& InvalidReply::page_buf() const {
  // @@protoc_insertion_point(field_get:dbx1000.InvalidReply.page_buf)
  return _internal_page_buf();
}
inline void InvalidReply::set_page_buf(const std::string& value) {
  _internal_set_page_buf(value);
  // @@protoc_insertion_point(field_set:dbx1000.InvalidReply.page_buf)
}
inline std::string* InvalidReply::mutable_page_buf() {
  // @@protoc_insertion_point(field_mutable:dbx1000.InvalidReply.page_buf)
  return _internal_mutable_page_buf();
}
inline const std::string& InvalidReply::_internal_page_buf() const {
  return page_buf_.Get();
}
inline void InvalidReply::_internal_set_page_buf(const std::string& value) {
  
  page_buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void InvalidReply::set_page_buf(std::string&& value) {
  
  page_buf_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:dbx1000.InvalidReply.page_buf)
}
inline void InvalidReply::set_page_buf(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  page_buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:dbx1000.InvalidReply.page_buf)
}
inline void InvalidReply::set_page_buf(const void* value,
    size_t size) {
  
  page_buf_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:dbx1000.InvalidReply.page_buf)
}
inline std::string* InvalidReply::_internal_mutable_page_buf() {
  
  return page_buf_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* InvalidReply::release_page_buf() {
  // @@protoc_insertion_point(field_release:dbx1000.InvalidReply.page_buf)
  return page_buf_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void InvalidReply::set_allocated_page_buf(std::string* page_buf) {
  if (page_buf != nullptr) {
    
  } else {
    
  }
  page_buf_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), page_buf,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:dbx1000.InvalidReply.page_buf)
}

// uint64 count = 3;
inline void InvalidReply::clear_count() {
  count_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InvalidReply::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 InvalidReply::count() const {
  // @@protoc_insertion_point(field_get:dbx1000.InvalidReply.count)
  return _internal_count();
}
inline void InvalidReply::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  count_ = value;
}
inline void InvalidReply::set_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:dbx1000.InvalidReply.count)
}

// -------------------------------------------------------------------

// GetNextTsRequest

// -------------------------------------------------------------------

// GetNextTsReply

// uint64 ts = 1;
inline void GetNextTsReply::clear_ts() {
  ts_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetNextTsReply::_internal_ts() const {
  return ts_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetNextTsReply::ts() const {
  // @@protoc_insertion_point(field_get:dbx1000.GetNextTsReply.ts)
  return _internal_ts();
}
inline void GetNextTsReply::_internal_set_ts(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  ts_ = value;
}
inline void GetNextTsReply::set_ts(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_ts(value);
  // @@protoc_insertion_point(field_set:dbx1000.GetNextTsReply.ts)
}

// -------------------------------------------------------------------

// TestRequest

// -------------------------------------------------------------------

// TestReply

// int32 rc = 1;
inline void TestReply::clear_rc() {
  rc_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TestReply::_internal_rc() const {
  return rc_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TestReply::rc() const {
  // @@protoc_insertion_point(field_get:dbx1000.TestReply.rc)
  return _internal_rc();
}
inline void TestReply::_internal_set_rc(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rc_ = value;
}
inline void TestReply::set_rc(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rc(value);
  // @@protoc_insertion_point(field_set:dbx1000.TestReply.rc)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dbx1000

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::dbx1000::RpcLockMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dbx1000::RpcLockMode>() {
  return ::dbx1000::RpcLockMode_descriptor();
}
template <> struct is_proto_enum< ::dbx1000::RpcRC> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dbx1000::RpcRC>() {
  return ::dbx1000::RpcRC_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_global_5flock_5fservice_2eproto
